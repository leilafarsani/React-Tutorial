Learning Objectives

Data fetching
Show some data from an API in a component.

Can explain why a loading state is necessary when fetching
data as the result is not available on the initial render
Be able to trigger fetch() using the useEffect() callback,
with an empty array ([]) as the 2nd dependencies argument
Be able to store data from a successful API call in state
Allow effects to update in response to prop changes
Explain why a component with an effect dependent on props is
broken with empty useEffect() dependencies ([])
Be able to fix a component with an effect dependent on props
using the useEffect() dependencies
Can describe the "lifecycle" of a component with useEffect()
when props change

Forms
Create a simple form in React using the controlled component pattern
Can initialise state with useState()
Be able to set the input value to the state variable
Can explain why the input does not change when typing if onChange is not set
Be able to update the state using an onChange handler
Use data from a submitted form to update the application
Be able to handle an onSubmit event to the form
Be able to collect the form state variables and use them
(setting state, POST request)

Fetching Data in React
Often when you create a React app, you will want to fetch data from an
API and display it inside your components. How do we do this in React?
You might think that we could just fetch the data in the component
like this, but unfortunately it won't work

This code won't work!

function MartianPhotoFetcher() {
  let imgSrc = null;

  fetch(
    `https://api.nasa.gov/mars-photos/api/v1/rovers/curiosity/photos?earth_date=2015-6-3&api_key=DEMO_KEY`
  )
    .then((res) => res.json())
    .then((data) => {
      imgSrc = data.photos[0].img_src;
    });

  console.log(`The image src is ${imgSrc}`);
  return <img src={imgSrc} />;
}
This is because React is synchronous, while fetch is asynchronous.
If we look in the console, we'll see that the imgSrc will always 
be null when we try to render it. React will try to render before 
fetch has had time to get the data from the API.

We need a way of running the fetch call after we have rendered for 
the first time, so that it is not racing against React updating the DOM. 
Then once we have got the data back we can use state to tell
React to re-render with the new data.

The way we do this is with another Hook, provided by React. This one is called useEffect.

Importing useEffect
Just like useState, we will import useEffect into our file like this

import React, { useEffect } from "react";

console.log(useEffect);

import React, { useState, useEffect } from "react";

Using useEffect
Now let's look at how to use the useEffect Hook 

function MartianPhotoFetcher() {
  useEffect(() => {
    fetch(
      `https://api.nasa.gov/mars-photos/api/v1/rovers/curiosity/photos?earth_date=2015-6-3&api_key=DEMO_KEY`
    )
      .then((res) => res.json())
      .then((data) => {
        console.log(data);
      });
  }, []); // Always remember to put an empty array here!

  return <div>Hello useEffect!</div>;
}

The useEffect Hook takes two arguments:

A callback function, where we can put our fetch call. 
In this example, we're fetching some data from the NASA API! ðŸš€
An array, which we'll look at later but is very important that you don't forget it!

NOTE
When writing your useEffect, write the "skeleton" first,
then fill in the callback function later.

// Write this bit first!
useEffect(() => {
  // Write this bit later!
}, []);

You might have noticed that we still haven't rendered the data 
from the API. We now need to tell React to re-render once we get 
the data. This sounds like a job for state!

Let's look an example of how we can use state and useEffect to do this

function MartianPhotoFetcher() {
  const [marsPhotoData, setMarsPhotoData] = useState(null);

  useEffect(() => {
    console.log("Fetching data from NASA");

    fetch(
      `https://api.nasa.gov/mars-photos/api/v1/rovers/curiosity/photos?earth_date=2015-6-3&api_key=DEMO_KEY`
    )
      .then((res) => res.json())
      .then((data) => {
        setMarsPhotoData(data);
      });
  }, []);

  if (marsPhotoData) {
    return <img src={marsPhotoData.photos[0].img_src} alt="Martian surface" />;
  } else {
    return null;
  }
}

The timeline of this component is now what we wanted at the start:

The component renders for the first time. Notice that we are returning
null here: if a component returns null, then React will render nothing on-screen
After rendering, the useEffect callback is run, so it fetches data from the NASA API
When the response is received, we update the state
This causes a re-render so that we can show the data on-screen
You might notice that even though we re-rendered, we did not run
the useEffect a second time. The way we've set it up, 
useEffect will only
run after the first time a component renders. 
We'll look at controlling this in more detail later.

Conditional rendering
In the MartianPhotoFetcher component above, we wrapped our JSX 
inside an if / else statement. This is common practice in React,
as it allows us to show something different depending on the situation 
(for example if there is no data to display, show the user something else instead).

You may also see this done in 2 other ways:

The ternary operator ? :
The ternary operator follows this structure condition ? outputIfTrue : outputIfFalse

return (
  <div>
    {marsPhotoData ? (
      <img src={marsPhotoData.photos[0].img_src} alt="Martian surface" />
    ) : (
      <span>Loading...</span>
    )}
  </div>
);

You'll notice in the && example above, we do not render a 'Loading...' message, 
because there is no alternative output (no else case).

The Circle of Life
We now know how to fetch data and render it in our React applications.
However, there was a problem with the method that just learned.
To understand this problem we first have to
understand the lifecycle of a component.

Let's take a look at an example:

Together let's "play computer" to break down exactly
what is happening with these components:

1. When the page loads, the App function component is called
2. It doesn't have any date state already, so we initialise it to
an empty string ("") with useState
3. It renders the 2 buttons, but because date is an empty string,
it does not render the MartianImageFetcher component. Instead null is returned,
which means that nothing is rendered

  function App() {
    const [date, setDate] = useState("");

    ...

    return (
      <div>
        <button onClick={handle2019Click}>Fetch image for 2019</button>
        <button onClick={handle2020Click}>Fetch image for 2020</button>

        {date ? <MartianImageFetcher photoDate={date} /> : null}
      </div>
    );
  }

4. When we click the "Fetch image for 2019" button, 
the handle2019Click click handler is called
5. The state is set by setDate to be "2019-01-01",
and a re-render is triggered
6. The App function component is called again
7. This time, useState remembers that we have date state 
and it is set to "2019-01-01"

  function App() {
    ...

    function handle2019Click() {
      setDate("2019-01-01");
    }

    ...

    return (
      ...
      <button onClick={handle2019Click}>Fetch image for 2019</button>
      ...
    );
  }

8. Now App does render MartianImageFetcher and passes the
date state as a prop named photoDate
9. The MartianImageFetcher function component is called for the first time
10. useState knows that we haven't got any imgSrc state so initialises it to null
11. We queue an effect, which will run after we render for the first time
12. Because the imgSrc state is set to null, we return null.
This means that nothing is rendered

  function MartianImageFetcher(props) {
    const [imgSrc, setImgSrc] = useState(null);

    useEffect(() => {
      ...
    }, []);

    if (!imgSrc) {
      return null;
    } else {
      return <img src={imgSrc} />;
    }
  }

13. Now that the component has rendered for the first time,
the effect is run
14. A fetch request is made to the NASA API
15. When the request data comes back, we set the imgSrc
state to a piece of the data, which triggers a re-render

  function MartianImageFetcher(props) {
    ...

    useEffect(() => {
      fetch(
        `https://api.nasa.gov/mars-photos/api/v1/rovers/curiosity/photos?earth_date=${
          props.date
        }&api_key=gnesiqnKCJMm8UTYZYi86ZA5RAnrO4TAR9gDstVb`
      )
        .then(res => res.json())
        .then(data => {
          setImgSrc(data.photos[0].img_src);
        });
    }, []);

    ...
  }

16. The MartianImageFetcher function component is called again
17. useState remembers that the imgSrc state is set to the data from the API
18. This time, we do not queue an effect. We set up useEffect
with an empty array ([]), which means that we only run after the first render
19. We do have imgSrc state set, so we render the image using the data from the API ðŸŽ‰

  function MartianImageFetcher(props) {
    const [imgSrc, setImgSrc] = useState(null);

    ...

    if (!imgSrc) {
      return null;
    } else {
      return <img src={imgSrc} />;
    }
  }

Phew! That was a lot of work just to render an image! 
But we're not quite done yet, we still need to find out 
what happens when we click the "Fetch image for 2020" button:

1. In the App component, the handle2020Click click handler is called
2. The date state is set to "2020-01-01" and a re-render is triggered
3. The App function component is called again and the date state is set to "2020-01-01"
4. The date prop that is passed to MartianImageFetcher is different
 which means that it has to re-render

  function App() {
    ...

    function handle2020Click() {
      setDate("2020-01-01");
    }

    ...

    return (
      ...
      <div>
        ...
        <button onClick={handle2020Click}>Fetch image for 2020</button>
        ...
        {date ? <MartianImageFetcher photoDate={date} /> : null}
        ...
      </div>
      ...
    );
  }

5. In the MartianImageFetcher component useState remembers that we already 
had imgSrc state. It is set to the image from 2019
6. Again, we do not queue the effect because this 
is a re-render and useEffect has been passed an empty array []
7. Because imgSrc state has been set previously we render the image from 2019

  function MartianImageFetcher(props) {
    const [imgSrc, setImgSrc] = useState(null);

    useEffect(() => {
      ...
    }, []);

    return <img src={imgSrc} />;
  }